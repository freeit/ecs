\hypertarget{devel}{}
\hypertarget{developing}{}
\chapter{Developing}\index{developing}
\section{Tools}
\subsection{Scriptable REST commandline client}
As the ECSA is derived from an architecture style for distributed systems
called REST, the major tool for developing in an ECSA context is a scriptable
REST commandline client. An excellent choice would be \cmd{curl}.
\subsubsection{Monitoring resources}
Following code monitors the events resource every 5 seconds and
shows/highlights the differences in the output:
\begin{code}
watch -n 5 --differences=cumulative --no-title \
'curl -i --cacert /path/to/freeit-root-ca.cert.pem \
     --cert /path/to/participant.cert.pem \
     --key /path/to/participant.key.pem \
     --pass "secure pwd" \
     -X GET https://ecscc.uni-stuttgart.de/ra/ecs-test/sys/events'
\end{code}

\hypertarget{devel-campusconnect}{}
\section{CampusConnect}
\subsection{Simulating LSFproxy}
To develop without a running LSFproxy you could simply provide static resources
inside the ECSA network. At ECS you have to create the specific CampusConnect
resources (\rs{/campusconnect/courses}, \rs{/campusconnect/directory\_trees} and
\rs{/campusconnect/course\_members}). The essential LSFproxy communication to ECS
could be substituted with curl scripts/calls. In presence of a LSFproxy, its
resource representations has to be retrieved indirectly through ECS (see
\ref{heading:participant_coursedata_retrieval_indirectly} on page
\pageref{heading:participant_coursedata_retrieval_indirectly} for retrieving
course representations). For each development party you should create a
separate LSFproxy participant at ECS. For easier usage we provide a shell script
\href{http://repo.or.cz/w/ecs.git/blob_plain/HEAD:/campusconnect/scripts/lsfproxy.sh}{(LSFproxy.sh)}
simulating an LSFproxy. Please have a look at the top of the script and adjust
the appropriate lines. For development we provide an ECS, LSFproxy certificates
and LSFproxy data. Please contact us (info[at]freeit[dot]de). Of course you can
drive all parts by your own and have to fill out the lines by your personal
data.

\subsubsection{Create}
To POST new LSFproxy course to a community participant (e.g. a LMS) call the
script like this:
\begin{code}
  ./lsfproxy.sh -c -k 11 -u 1 create

  -c ... you want to work with courses
  -k ... you address membership 11
  -u ... static course data with DATA_URL1 (see top of LSFproxy.sh)
  create ... POST this message to ECS (URL of ECS see top of LSFproxy.sh)
\end{code}
For a new LSFproxy directory-tree:
\begin{code}
  ./lsfproxy.sh -t -k 11 -u 3 create

  -t ... you want to work with trees
  -k ... you address membership 11
  -u ... static tree data with DATA_URL3 (see top of LSFproxy.sh)
  create ... POST this message to ECS (URL of ECS see top of LSFproxy.sh)
\end{code}

You always have to choose the appropriate DATA\_URL (see top of LSFproxy.sh)
that correspondents to the resource you want to operate on ECS. Feel free to
download these static representations from the URLs assigned to the DATA\_URL
constatnts at top of the script and setup your own static LSFproxy data
representations at your local web sever.

\subsubsection{Get, Delete and Update}
After you have created some messages, you can of course DELETE them (you are
the owner). But first you have to distinguish the resource id on ECS. Either
you have noticed the id at creation time looking at the provided \hv{Location}
header from ECS or you request first a resource listing and second request a
resource representation from this id checking it is the right one before
deleting it:
\begin{code}
  ./lsfproxy.sh -c get
  -c ... you want to work with courses
  get ... get a list of the resource

  ./lsfproxy.sh -c -i 2445 delete
  -c ... you want to work with courses
  -i ... resource id
  delete ... delete resource
\end{code}
In order to update a resource call the script like this:
\begin{code}
  ./lsfproxy.sh -c -i 2445 -k 11 -u 4 update
  -c ... you want to work with courses
  -i ... resource id
  -k ... you address membership 11
  -u ... static course data with DATA_URL4
  update ... POST this message to ECS
\end{code}

\subsubsection{Show Memberships}
You can also show your memberships by calling:
\begin{code}
  ./lsfproxy.sh -s get
\end{code}

\subsubsection{Show Usage}
And last you can show a usage help text by calling the script with no
parameters and options or with the \kw{-h} option:
\begin{code}
  ./lsfproxy.sh -h

  Usage: lsfproxy.sh options <create|get|delete|update>
  Options:
    -c ... courses
    -m ... course members
    -t ... directory trees
    -s ... memberships
    -i <resource id>
    -k <membership id>
    -u <data url id>
    -v   ... verbose output
    -h|? ... usage
\end{code}
Please remember, this script is only a help utility, not full-fledged
application. So please adjust it to your needs. 

\hypertarget{campusconnect_json_schemas}{}
\subsection{JSON-Schemas}
A json media type for describing the structure and meaning of json documents.
It's \href{http://tools.ietf.org/html/draft-zyp-json-schema-03}{defined} as an
Internet-Draft working document of the IETF\nc{Internet Engineering Task
Force}~. There is also a \href{http://json-schema.org}{homepage} where you can
start to discover more over JSON-Schemas.

All resource representations must have a \hv{Content-Type} header variable
containing an optional parameter \hv{profile} pointing to its describing
schema. For a respond on a \rs{/campusconnect/courses} request this could be:
\begin{verbatim}
Content-Type: application/json; \
              profile=http://repo.or.cz/w/ecs.git/blob_plain/ \
              e5cc81b2201ac24294d2ac3e732f9ddac954cc84:/ \
              campusconnect/schemas/cc_courses.schema.json
\end{verbatim}
It's up to you to validate and check the received data against the provided
schema or to decide if you are able to process the format just receiving. There
is always a version id inbetween the \hv{profile} URL representing the commit
id of the git repository. For the last \hv{Content-Type} example this was
\verb!e5cc81b2201ac24294d2ac3e732f9ddac954cc84!~. You can always ask for the
latest schema of an appropriate resourse by using \verb!HEAD! as the version
id.

Of course you can use the schema of an appropriate resource for discovering the
names and types of the data elements in order to match them dynamically to
other internal meta data of your application.


\hypertarget{campusconnect_resources}{}
\subsection{Resources}

\hypertarget{campusconnect_cources}{}
\subsubsection{/campusconnect/courses}
\href{https://ecs.uni-stuttgart.de/ecsa-wiki/CampusConnect/Arbeitspakete/EcsREST/CmsCourses}{Example representation} and
\href{http://repo.or.cz/w/ecs.git/blob_plain/HEAD:/campusconnect/schemas/cc_courses.schema.json}{Schema definition}.

\hypertarget{campusconnect_organisation_units}{}
\subsubsection{/campusconnect/organisation\_units}
\href{https://ecs.uni-stuttgart.de/ecsa-wiki/CampusConnect/Arbeitspakete/EcsREST/CmsInstitutions}{Example representation} and
\href{http://repo.or.cz/w/ecs.git/blob_plain/HEAD:/campusconnect/schemas/cc_organisation_units.schema.json}{Schema definition}.

\hypertarget{campusconnect_terms}{}
\subsubsection{/campusconnect/terms}
\href{https://ecs.uni-stuttgart.de/ecsa-wiki/CampusConnect/Arbeitspakete/EcsREST/CmsSemesters}{Example representation} and
\href{http://repo.or.cz/w/ecs.git/blob_plain/HEAD:/campusconnect/schemas/cc_terms.schema.json}{Schema definition}.

\hypertarget{campusconnect_course_members}{}
\subsubsection{/campusconnect/course\_members}
\href{https://ecs.uni-stuttgart.de/ecsa-wiki/CampusConnect/Arbeitspakete/EcsREST/CmsCourseMembers}{Example representation} and
\href{http://repo.or.cz/w/ecs.git/blob_plain/HEAD:/campusconnect/schemas/cc_course_members.schema.json}{Schema definition}.

\hypertarget{campusconnect_directory_trees}{}
\subsubsection{/campusconnect/directory\_trees}
\href{https://ecs.uni-stuttgart.de/ecsa-wiki/CampusConnect/Arbeitspakete/EcsREST/CmsDirectoryTrees}{Example representation} and
\href{http://repo.or.cz/w/ecs.git/blob_plain/HEAD:/campusconnect/schemas/cc_directory_trees.schema.json}{Schema definition}.



