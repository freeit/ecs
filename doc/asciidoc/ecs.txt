ECS
---
(((ECS)))
The elearning community server (ECS) is designed as a message oriented
middleware (MOM) and is implemented as a
http://en.wikipedia.org/wiki/REST[REST] conform application.

Because the ECS was born in an elearning context the following definition shows
consideration of that. Nevertheless the ECS could be used in other areas of
responsibility.

The ECS groups its participants in so called _communities_. Participants
could address each other only if they share a community. Therefore they could
address an explicit participant, a participant list or the whole members of the
community (see ECS API for details).

All participants have to register at the ECS. Every registered participant has
access to at least three system resources (`/sys/memberships`,
`/sys/events`, `/sys/auths`) to get informed and take part at a ECSA
network. To design/map your specific application communication you can create as many
application resources you want.

HTTP Header
~~~~~~~~~~~
ECS specific headers
^^^^^^^^^^^^^^^^^^^^
X-EcsAuthId::
  Has to be a valid participant id. In a standard ECS configuration this HTTP
  header will be attached by the authentication process running on the proxy
  server. 
X-EcsReceiverCommunities::
  Has to be a valid community id/ids or community name/names. Adresses all
  participants joined the comimunity/communities. You are able to note
  multiple communities, either by name or by id, spaced by comma. Only allowed by POST. 
X-EcsReceiverMemberships::
  Has to be a valid membership id/ids. Adresses all listed memberships. You are
  able to note multiple memberships spaced by comma.  Only allowed by POST. 
X-EcsSender::
  Describes the sender of a message. If you GET a resource this header variable
  shows the sender membership id. Additionally the ECS sets the
  X-EcsReceiverCommunities variable to the community from which you have
  received the message. If the message reach you from several communities
  X-EcsSender show you a comma separated list of membership ids representing
  the appropriate membership id of the sender in these communities. In this
  case the X-EcsReceiverCommunities variable would also represent a comma
  seperated list of a corresponding community ids.
X-EcsQueryStrings::
  Used to provide querystrings.
// make link to querystrings 

HTTP standard header
^^^^^^^^^^^^^^^^^^^^
Accept::
  Content-Types that are acceptable.
Content-Type::
  The mime type of the body of the request (used with POST and PUT requests).
If-None-Match::
  Allows a 304 Not Modified to be returned if content is unchanged.
Cookie::
  An HTTP cookie previously sent by the server with Set-Cookie.
Content-Type::
  The mime type of this content.
ETag::
  An identifier for a specific version of a resource.
Location::
  Used in redirection, or when a new resource has been created.
Set-Cookie::
  An HTTP cookie.

HTTP return codes
~~~~~~~~~~~~~~~~~
200::
  Successful GET.
201::
  Successful POST.
304::
  A _Not Modified_ response on a conditional GET. This means the requested
  resource has not been changed.
404::
  Resource not available.
4xx::
  General client side error.
5xx::
  General server side errors.

Addressing
~~~~~~~~~~
In order to communicate to each other you have to provide a unique address.
These addresses can either be a so called membership id or a community id or
community name. 

Membership IDs
^^^^^^^^^^^^^^
These are unique ids in the scope of an ECS. They establish a relationship
between a participant and a community:

 +------------+ 1        N +-----------+ N        1 +-----------+
 |participants|------------|memberships|------------|communities|
 +------------+            +-----------+            +-----------+

Therefore a participant can be associated to different communities. Every
participant can inquire his membership ids by calling the memberships
resource.
// make link to memberships

Community names and ids
^^^^^^^^^^^^^^^^^^^^^^^
A community can be referenced by his community id (cid) or his community name.
If you address a community you implicit address all members of the community.
This applies also to the sender joining the receiver community if the sender
has set his community_selfrouting flag (default off), otherwise the sender will
be implicitly excluded from the receiver list. Every participant can inquire
his communities memberships by calling the memberships resource.
// make link to memberships

Create a resource
^^^^^^^^^^^^^^^^^^
If you want to POST to a resource you have to provide either a
`X-EcsReceiverMemberships` or `X-EcsReceiverCommunities` header or both together.

If you want to address a single membership or a dedicated number of memberships
you have to set the `X-EcsReceiverMemberships` header. This header can have a
list of values, e.g.

------------------------------------------------------
X-EcsReceiverMemberships: 3,6,47
------------------------------------------------------

If you want to address a community you have to set the `X-EcsReceiverCommunities`
header. This header can have a list of values, e.g.

------------------------------------------------------
X-EcsReceiverCommunities: SWS,23,25
------------------------------------------------------

Get a resource
^^^^^^^^^^^^^^
If you GET a resource then the ECS set the `X-EcsSender` and the
`X-EcsReceiverCommunities` header to show you from whom and where your received
message comes. If there is a list of `X-EcsReceiverCommunities` values than there
is also a list of corresponding `X-EcsSender` values, i.e. the sending
participant is member of multiple communities and addressed his message to
multiple communities also, e.g.

------------------------------------------------------
X-EcsSender: 3,19
X-EcsReceiverCommunities: UnisBW,SUV
------------------------------------------------------

This means that this message is addressed to you through two communities
(UnisBW, SUV) and the sender has the membership id 3 in UnisBW and 19 in SUV.


Community selfrouting
~~~~~~~~~~~~~~~~~~~~~
(((selfrouting)))
(((ECS,selfrouting)))
If community selfrouting is activated at the participant (administration area)
you can decide if you also want to receive the message which you send to an
appropriate community, i.e. you get an event notification (if events on this
resource is activated) and you get it listed by its
https://ecs.uni-stuttgart.de/ecsa-wiki/HeikoBernloehr/FreeLancer/ECS/ecs2/core#list-ressource[list
resource] and could access it through its
https://ecs.uni-stuttgart.de/ecsa-wiki/HeikoBernloehr/FreeLancer/ECS/ecs2/core#queue-ressource[queue
resource]. Of course, as sender of the message you can always access it by its
https://ecs.uni-stuttgart.de/ecsa-wiki/HeikoBernloehr/FreeLancer/ECS/ecs2/core#message-resource[message
resource]. 


Authentication
~~~~~~~~~~~~~~
(((authentication)))
(((ECS,authentication)))
All participants have to be authenticated in order to use ECS services. A
participant is deemed to be authenticated if the `X-EcsAuthId` header is set and
the ECS knows it. The real authentication take place in front of the ECS,
normally at the Webserver. But this depends on configuration/installation of
ECS:

.Message flow through ECS application.
[[fig:ecs_message_flow]]

   +-----------+    .        
   |   ECS     |   /_\       
   | (RAILS)   |    |        
   +-----------+    |        
   |Rack Module|    |        
   | (optional)|    |        
   +-----------+    | Message
   | Webserver |    | Flow   
   |  (Proxy)  |    |        
   +-----------+    |        
         |          |        
   +-----------+    |        
   |Participant|    |        
   +-----------+             

Currently supported authentication methods:

- Basic Auth
- X.509 certificates

Anonymous participants
~~~~~~~~~~~~~~~~~~~~~~
(((anonymous-participants)))
(((ECS,anonymous participants)))
The creation of a new anonymous participant automatically takes place by every
call to an ECS resource if the calling participant didn't set `X-EcsAuthId` or
`Cookie` header, by setting a `Set-Cookie` header in the response. On
subsequent calls the participant has to provide this cookie in a `Cookie`
header in order to be identified as the previously calling participant.
Additionally those participants were automatically joined to the 'public'
community. Further their lifetime will be limited and all resources will be
silently deleted after this lifetime becomes zero. With succesional accesses to
ECS this lifetime will be refreshed. For general cookie handling see also
http://en.wikipedia.org/wiki/HTTP_cookie[HTTP cookies]. See also
https://ecs.uni-stuttgart.de/ecsa-wiki/HeikoBernloehr/FreeLancer/ECS/ecs2/core/examples[examples].


System resources
~~~~~~~~~~~~~~~~
(((resources)))
(((system resources)))
(((ECS,system resources)))

Events
^^^^^^
(((events resource)))
(((ECS,events resource)))
Provides a general queue which accumulates the resource tasks: creation,
deletion and renewal. Available representations are application/json and
application/xml. It's recommended to use the events queue to supervise all your
possible application specific resources. Further you only have to poll the
events queue in order to supervise all your application specific resources and
this further take down system load. 

Remark: If you wisely decide to use the events queue to supervise your
application specific resources you have to manage the validity of events queue
yourself, i.e. you shouldn't additionally poll your application specific
resources directly, because then you will get stale events in the events
queue. 

/sys/events:: GET provides a list of events for the appropriate calling
  participant. Optionally the query string parameter 'count' could be used
  to limit the amount of returned events. 
/sys/events/fifo:: GET provides an event (the oldest one) for the
  appropriate calling participant. Optionally the query string parameter
  'count' could be used to extend the amount of returned events.  POST
  provides an event (the oldest one) for the appropriate calling participant
  and removes it from the events queue. Optionally the query string parameter
  'count' could be used to extend the amount of returned events.

Following a sample representation in JSON:

------------------------------------------
[
  {
    "status": "created",
    "ressource": "numlab/exercises/7"
  },
  {
    "status": "destroyed",
    "ressource": "numlab/exercises/3"
  }
]
------------------------------------------


Memberships
^^^^^^^^^^^
(((memberships resource)))
(((ECS,memberschips resource)))
Provides information of the affiliation of the calling participant to the
available communities. Available representations are `application/json` and
`application/xml`.

/sys/memberships:: GET provides a list of memberships for the
  appropriate calling participant. It implies all participants joining an
  appropriate community including the caller itself.

With the `itsyou` key the caller of the `/sys/memberships` resource will be
informed which participant in the different communities is assigned to him.

Following a sample representation in JSON:

-------------------------------------------------------
[
  {
    "community": {
      "name": "cc_courselinks",
      "description": "CampusConnect courselinks."
    },
    "participants": [
      {
        "name": "ILIAS-ECS Client 1",
        "itsyou": true,
        "org": {
          "name": "Leifos",
          "abbr": "LEI"
        },
        "mid": 1,
        "description": "Development participant.",
        "dns": "n/a",
        "email": "meyer@leifos.com"
      },
      {
        "name": "FreeIT.de Testparticipant",
        "itsyou": false,
        "org": {
          "name": "FreeIT Softwaredevelopment.",
          "abbr": "FreeIT"
        },
        "mid": 2,
        "description": "A general test participant.",
        "dns": "n/a",
        "email": "Heiko.Bernloehr@FreeIT.de"
      },
      {
        "name": "ILIAS-ECS Client 2",
        "itsyou": false,
        "org": {
          "name": "Leifos",
          "abbr": "LEI"
        },
        "mid": 3,
        "description": "",
        "dns": "n/a",
        "email": "meyer@leifos.com"
      }
    ]
  }
]
-------------------------------------------------------

Auths
^^^^^
(((auths resource)))
(((ECS,auths resource)))
This means authorization through one touch tokens. Provides a mechanism to
grant each participant authorization to consume services from any
service-providing-participant in an ECS network.

The interface is the same as for
https://ecs.uni-stuttgart.de/ecsa-wiki/HeikoBernloehr/FreeLancer/ECS/ecs2/core#application_resources[application
resources]. If you want to create an authorization token, you have to provide
at least a json formated URL (authorization context) as body text:

-------------------------------------------------------
curl ... -X POST -d '{"url":"https://freeit.de/mycourse"}' https://.../sys/auths
-------------------------------------------------------

and you will get back something like this:

-------------------------------------------------------
{
  "hash": "5a944e72346e6e3102d32ccfecc18862d23e1dc0",
  "sov": "2011-03-08T23:25:27+01:00",
  "eov": "2011-03-08T23:26:27+01:00",
  "url": "https://freeit.de/testcourse",
  "abbr": "LEI"
}
-------------------------------------------------------

hash:: povides the authorization token (one touch token) 
sov:: stands for start of validation 
eov:: stands for end of validation 
url:: provides the authorization context 
abbr:: provides an abbreviation of the participant which has been
  created the authorization token (deprecated) 

You're allowed to set the `sov` and/or `eov` to distinguish the validity
period of the authorization token. If you do not, the validity period is set to
one minute starting at current time.

The recommended way to fetch an authorization token when knowing the one touch hash:

-------------------------------------------------------
curl .... -X DELETE https://.../sys/auths/<one touch hash>
-------------------------------------------------------

This will return the auths representation (same structure/form as when
creating; see above) and delete it server side. If the authorization token is
outtimed, i.e. the current time is not between `sov` and `eov`, you will
get back a return code 409 (conflict) and following descriptional text in the
body: 'Authorization token outtimed'.

Application specific resources
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(((resources)))
(((application resources)))
(((ECS,application resources)))
All application specific resources have to be configured at ECS. There are three types of application specific resources:

1. messages
2. lists
3. queues

Generally resources are an abtract concept:

* clearly identifiable (in an HTTP context through URLs)
* have one ore more representations (e.g. JSON, XML, text, ...)

According to resources it plays no role how a representation is produced. It
could be done by returning a static file or running a complex server side
application, that doesn't matter. Furthermore by looking at a resource you
can't conclude how the representation has been made. An evaluation of a
resource based on internal operations and circumstances, it is thus also
negligible, and even be inadmissible.

Resource structure
^^^^^^^^^^^^^^^^^^

 /<projectnamespace>/<name>
 /<projectnamespace>/<name>/details
 /<projectnamespace>/<name>/<id>
 /<projectnamespace>/<name>/<id>/receivers
 /<projectnamespace>/<name>/<id>/details
 /<projectnamespace>/<name>/fifo
 /<projectnamespace>/<name>/lifo


Message resource
^^^^^^^^^^^^^^^^
A message resource receives/saves messages for each participant. The
participant can fetch (GET) his messages from the resource. A message resource
could hold its messages enduringly (see <<_postrouting>>), so new participants
joining a community after a message has been sent to this community will also
receive it. 

GET::
  Returns message with status code 200.
DELETE::
  Deletes message and returns deleted resource representation with ststus code 200.
PUT::
  Renew message and returns with status code 200.
POST::
  Illegal call. Returns with status code 405 (Method Not Allowed).

Resource structure: `/<projectnamespace>/<name>/<id>`

Subresource details
+++++++++++++++++++

You can ask for detailed (meta) information of a posted message. Only the
original sender or a receiver can do that:

GET::
  Returns details about the requested message.

Resource structure: `/<projectnamespace>/<name>/<id>/details`

You will get back something like this:

 {
   "receivers": [
     {
       "itsyou": false,
       "mid": 1,
       "cid": 2
       "pid": 19,
     },
     {
       "itsyou": false,
       "mid": 4,
       "cid": 3
       "pid": 29,
     }
   ],
   "senders": [
     {
       "mid": 5
     },
     {
       "mid": 7
     }
   ],
   "url": "courselinks/10",
   "content_type": "application/json"
   "owner": {
     "pid": 3,
     "itsyou": true
   }
 }

The "receivers" and "senders" have corresponding arrays: The first array entry
in "senders" has been addressed the first array entry of "receivers" and so on. 

List resource
^^^^^^^^^^^^^
GET::
  Returns URI message list  with status code 200. If there are no messages to
  list the HTTP body will be empty (`Content-Length: 0`). The `Content-Type`
  will be `text/uri-list`. The URI list will be represented by
  http://www.rfc-ref.org/RFC-TEXTS/3986/chapter5.html[relative references]. URIs
  are specified in http://www.rfc-ref.org/RFC-TEXTS/3986[RFC3986].
DELETE::
  Illegal call. Returns with status code 405 (Method Not Allowed).
PUT::
  Illegal call. Returns with status code 405 (Method Not Allowed).
POST::
  Creates new message, returns with status code 201 and a HTTP header
  `Location:` providing the new message URI.

Resource structure: `/<projectnamespace>/<name>`

Subresource details
+++++++++++++++++++
Now it's possible to ask for detailed (meta) information of a list resource.
All querystrings supported my normal list resources could be used. Only the
original sender can do that:

GET::
  Returns details about all resource URIs listed.

Resource structure: `/<projectnamespace>/<name>/details`

You will get back something like this:

 [
   {
     "senders": [
 
     ],
     "receivers": [
 
     ],
     "url": "courselinks/35",
     "content_type": "text/plain",
     "owner": {
       "pid": 3,
       "itsyou": true
     }
   },
   {
     "senders": [
       {
         "mid": 2
       }
     ],
     "receivers": [
       {
         "mid": 19,
         "cid": 2,
         "pid": 19,
         "itsyou": false
       }
     ],
     "url": "courselinks/36",
     "content_type": "text/plain",
     "owner": {
       "pid": 3,
       "itsyou": true
     }
   },
   {
     "senders": [
       {
         "mid": 2
       }
     ],
     "receivers": [
       {
         "mid": 19,
         "cid": 2,
         "pid": 19,
         "itsyou": false
       }
     ],
     "url": "courselinks/37",
     "content_type": "text/plain",
     "owner": {
       "pid": 3,
       "itsyou": true
     }
   }
 ]

The first element of the returned array of the details list subresource
probably needs some explanation. Both senders and receivers are empty lists.
This means that the appropriate message isn't any more addressed to any
participant. This further implies that all participants which had been
addressed in the past have been received the message from their appropriate
resource.  But why was the message then not deleted ? Because the
resource has been configured to be "postrouted". If that has not been the case,
ECS would has been removed the message.

Querystrings
++++++++++++
To affect the returned representation you could assign the following
querystrings to `X-EcsQueryStrings` header variable:

receiver::
  It's possible to filter the returned index from a list resource to only those
  items to which the calling participant was formerly an addressed receiver:

    curl .... -H 'X-EcsQueryStrings: receiver=true' -X GET https://server/<namespace>/<name>
    This is also the default, therefore it could be omited.

sender::
  It's possible to filter the returned index from a list resource to only those
  items to which the calling participant is the original sender:
  
    curl .... -H 'X-EcsQueryStrings: sender=true' -X GET https://server/<namespace>/<name>

all::
  It's possible to filter the returned index from a list resource to show all
  messages either as addressed receiver or as original sender:

    curl .... -H 'X-EcsQueryStrings: all=true' -X GET https://server/<namespace>/<name>

Using the `X-EcsQueryStrings` header variable is the recommended way to use
querystrings. If you have to assign multiple querystrings please delimit the
querystrings by comma (,).

Of course you can also specify the querystring by appending it to the end of
the resource url, e.g.

 curl .... -X GET https://server/<namespace>/<name>?all=true

Queue resource
^^^^^^^^^^^^^^
The queue resource is modelled as a subresource of a list resource and it can
operate either in lifo (last in first out) or fifo (first in first out) mode.

GET::
  Returns last (lifo) or first (fifo) message with status code 200. If there
  are no more messages in queue you will get an empty message (`Content-Length:
  0`) and also status code 200.
DELETE::
  Illegal call. Returns with status code 405 (Method Not Allowed).
POST::
  Returns last (lifo) or first (fifo) message with status code 200 and deletes it. 
  If there are no more messages in queue you will get an empty message
  (`Content-Length: 0`) and also status code 200.
PUT::
  Illegal call. Returns with status code 405 (Method Not Allowed).

Resource structure: `/<projectnamespace>/<name>/fifo` or `/<projectnamespace>/<name>/lifo`

Postrouting
^^^^^^^^^^^
If a resource has set its postroute flag, then all new participants will get
postrouted this resources e.g. if you have posted some messages to a community
named testcommunity and later joins a new participant to this community, he
will get postrouted the former posted messages. 

Participant Cluster
~~~~~~~~~~~~~~~~~~~
The ECS is able to cluster participants. In the ECS network a cluster is seen
as an ordinary participant.

Cluster building
^^^^^^^^^^^^^^^^
First lets show the topology of a clustered ECS network:

 +---------+  +---------+  +---------+
 | Partic. |  | Partic. |  | Partic. |
 |    A    |  |    B    |  |    C    |
 +---------+  +---------+  +---------+
      |            |            |     
      |            |            |     
 +-----------------------------------+
 |                ECS                |
 +-----------------------------------+
                   |                  
                   |                  
 +-----------------------------------+
 | virtueller Participant (Cluster)  |
 +--------+--------+--------+--------+
 | Cluster| Cluster| Cluster| Cluster|
 | Partic.| Partic.| Partic.| Partic.|
 |    1   |    2   |   3    |   n    |
 +--------+--------+--------+--------+


1. The ECS registers a virtual participant. All cluster participants use this
   registration, i.e. the ECS doesn't know which cluster participant is
   communicating. This way you can scale your cluster easily by attaching
   another cluster participant also using the previously generated virtual
   participant registration. You don't have to make any further settings at
   ECS.
2. If you want to send a message to the cluster you only have to send it to the virtual
   participant. When all cluster participants compete against each other to get
   a message this would maybe the simplest resource access mode (message
   dispatching). Every cluster participant have to access the appropriate
   resource as a queue resource via DELETE method. This assures that every
   message could only be fetched by one cluster participant.

Cluster broadcasting
^^^^^^^^^^^^^^^^^^^^
In order to explicitely communicate with a cluster participant we have to use a
broadcasting mechanism. Every resource could be used as a broadcasting
resource. It only depends on how the cluster participants access this resource.
They have to do it like this:

1. Every cluster participant checks the broadcast resource as a queue resource with the idempotent
   GET method and decides by looking inside the message if this message is
   targeted to him. If it does belong to him he should compute and DELETE the
   message. 
2. The ECS garbage collects the broadcast resource at a default time period.



