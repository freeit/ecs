ECS
---
(((ECS)))
The elearning community server (ECS) is designed as a message oriented
middleware (MOM) and is implemented as a
http://en.wikipedia.org/wiki/REST[REST] conform application.

Because the ECS was born in an elearning context the following definition shows
consideration of that. Nevertheless the ECS could be used in other areas of
responsibility.

The ECS groups its participants in so called _communities_. Participants
could address each other only if they share a community. Therefore they could
address an explicit participant, a participant list or the whole members of the
community (see ECS API for details).

All participants have to register at the ECS. Every registered participant has
access to at least three system resources (`/sys/memberships`,
`/sys/events`, `/sys/auths`) to get informed and take part at a ECSA
network. To design/map your specific application communication you can create as many
application resources you want.

HTTP Header
~~~~~~~~~~~
ECS specific headers
^^^^^^^^^^^^^^^^^^^^
X-EcsAuthId::
  Has to be a valid participant id. In a standard ECS configuration this HTTP
  header will be attached by the authentication process running on the proxy
  server. 
X-EcsReceiverCommunities::
  Has to be a valid community id/ids or community name/names. Adresses all
  participants joined the comimunity/communities. You are able to note
  multiple communities, either by name or by id, spaced by comma. Only allowed by POST. 
X-EcsReceiverMemberships::
  Has to be a valid membership id/ids. Adresses all listed memberships. You are
  able to note multiple memberships spaced by comma.  Only allowed by POST. 
X-EcsSender::
  Describes the sender of a message. If you GET a resource this header variable
  shows the sender membership id. Additionally the ECS sets the
  X-EcsReceiverCommunities variable to the community from which you have
  received the message. If the message reach you from several communities
  X-EcsSender show you a comma separated list of membership ids representing
  the appropriate membership id of the sender in these communities. In this
  case the X-EcsReceiverCommunities variable would also represent a comma
  seperated list of a corresponding community ids.
X-EcsQueryStrings::
  Used to provide querystrings.
// make link to querystrings 

HTTP standard header
^^^^^^^^^^^^^^^^^^^^
Accept::
  Content-Types that are acceptable.
Content-Type::
  The mime type of the body of the request (used with POST and PUT requests).
If-None-Match::
  Allows a 304 Not Modified to be returned if content is unchanged.
Cookie::
  An HTTP cookie previously sent by the server with Set-Cookie.
Content-Type::
  The mime type of this content.
ETag::
  An identifier for a specific version of a resource.
Location::
  Used in redirection, or when a new resource has been created.
Set-Cookie::
  An HTTP cookie.

Addressing
~~~~~~~~~~
In order to communicate to each other you have to provide a unique address.
These addresses can either be a so called membership id or a community id or
community name. 

Membership IDs
^^^^^^^^^^^^^^
These are unique ids in the scope of an ECS. They establish a relationship
between a participant and a community:

 +------------+ 1        N +-----------+ N        1 +-----------+
 |participants|------------|memberships|------------|communities|
 +------------+            +-----------+            +-----------+

Therefore a participant can be associated to different communities. Every
participant can inquire his membership ids by calling the memberships
resource.
// make link to memberships

Community names and ids
^^^^^^^^^^^^^^^^^^^^^^^
A community can be referenced by his community id (cid) or his community name.
If you address a community you implicit address all members of the community.
This applies also to the sender joining the receiver community if the sender
has set his community_selfrouting flag (default off), otherwise the sender will
be implicitly excluded from the receiver list. Every participant can inquire
his communities memberships by calling the memberships resource.
// make link to memberships

Create a resource
^^^^^^^^^^^^^^^^^^
If you want to POST to a resource you have to provide either a
`X-EcsReceiverMemberships` or `X-EcsReceiverCommunities` header or both together.

If you want to address a single membership or a dedicated number of memberships
you have to set the `X-EcsReceiverMemberships` header. This header can have a
list of values, e.g.

------------------------------------------------------
X-EcsReceiverMemberships: 3,6,47
------------------------------------------------------

If you want to address a community you have to set the `X-EcsReceiverCommunities`
header. This header can have a list of values, e.g.

------------------------------------------------------
X-EcsReceiverCommunities: SWS,23,25
------------------------------------------------------

Get a resource
^^^^^^^^^^^^^^
If you GET a resource then the ECS set the `X-EcsSender` and the
`X-EcsReceiverCommunities` header to show you from whom and where your received
message comes. If there is a list of `X-EcsReceiverCommunities` values than there
is also a list of corresponding `X-EcsSender` values, i.e. the sending
participant is member of multiple communities and addressed his message to
multiple communities also, e.g.

------------------------------------------------------
X-EcsSender: 3,19
X-EcsReceiverCommunities: UnisBW,SUV
------------------------------------------------------

This means that this message is addressed to you through two communities
(UnisBW, SUV) and the sender has the membership id 3 in UnisBW and 19 in SUV.


Community selfrouting
~~~~~~~~~~~~~~~~~~~~~
(((selfrouting)))
(((ECS,selfrouting)))
If community selfrouting is activated at the participant (administration area)
you can decide if you also want to receive the message which you send to an
appropriate community, i.e. you get an event notification (if events on this
resource is activated) and you get it listed by its
https://ecs.uni-stuttgart.de/ecsa-wiki/HeikoBernloehr/FreeLancer/ECS/ecs2/core#list-ressource[list
resource] and could access it through its
https://ecs.uni-stuttgart.de/ecsa-wiki/HeikoBernloehr/FreeLancer/ECS/ecs2/core#queue-ressource[queue
resource]. Of course, as sender of the message you can always access it by its
https://ecs.uni-stuttgart.de/ecsa-wiki/HeikoBernloehr/FreeLancer/ECS/ecs2/core#message-resource[message
resource]. 


Authentication
~~~~~~~~~~~~~~
(((authentication)))
(((ECS,authentication)))
All participants have to be authenticated in order to use ECS services. A
participant is deemed to be authenticated if the `X-EcsAuthId` header is set and
the ECS knows it. The real authentication take place in front of the ECS,
normally at the Webserver. But this depends on configuration/installation of
ECS:

.Message flow through ECS application.
[[fig:ecs_message_flow]]

   +-----------+    .        
   |   ECS     |   /_\       
   | (RAILS)   |    |        
   +-----------+    |        
   |Rack Module|    |        
   | (optional)|    |        
   +-----------+    | Message
   | Webserver |    | Flow   
   |  (Proxy)  |    |        
   +-----------+    |        
         |          |        
   +-----------+    |        
   |Participant|    |        
   +-----------+             

Currently supported authentication methods:

- Basic Auth
- X.509 certificates

Anonymous participants
~~~~~~~~~~~~~~~~~~~~~~
(((anonymous-participants)))
(((ECS,anonymous participants)))
The creation of a new anonymous participant automatically takes place by every
call to an ECS resource if the calling participant didn't set `X-EcsAuthId` or
`Cookie` header, by setting a `Set-Cookie` header in the response. On
subsequent calls the participant has to provide this cookie in a `Cookie`
header in order to be identified as the previously calling participant.
Additionally those participants were automatically joined to the 'public'
community. Further their lifetime will be limited and all resources will be
silently deleted after this lifetime becomes zero. With succesional accesses to
ECS this lifetime will be refreshed. For general cookie handling see also
http://en.wikipedia.org/wiki/HTTP_cookie[HTTP cookies]. See also
https://ecs.uni-stuttgart.de/ecsa-wiki/HeikoBernloehr/FreeLancer/ECS/ecs2/core/examples[examples].


System resources
~~~~~~~~~~~~~~~~
(((system resources)))
(((ECS,system resources)))

Events
^^^^^^
(((events resource)))
(((ECS,events resource)))
Provides a general queue which accumulates the resource tasks: creation,
deletion and renewal. Available representations are application/json and
application/xml. It's recommended to use the events queue to supervise all your
possible application specific resources. Further you only have to poll the
events queue in order to supervise all your application specific resources and
this further take down system load. 

Remark: If you wisely decide to use the events queue to supervise your
application specific resources you have to manage the validity of events queue
yourself, i.e. you shouldn't additionally poll your application specific
resources directly, because then you will get stale events in the events
queue. 

/sys/events:: GET provides a list of events for the appropriate calling
  participant. Optionally the query string parameter 'count' could be used
  to limit the amount of returned events. 
/sys/events/fifo:: GET provides an event (the oldest one) for the
  appropriate calling participant. Optionally the query string parameter
  'count' could be used to extend the amount of returned events.  POST
  provides an event (the oldest one) for the appropriate calling participant
  and removes it from the events queue. Optionally the query string parameter
  'count' could be used to extend the amount of returned events.

Following a sample representation in JSON:

------------------------------------------
[
  {
    "status": "created",
    "ressource": "numlab/exercises/7"
  },
  {
    "status": "destroyed",
    "ressource": "numlab/exercises/3"
  }
]
------------------------------------------


Memberships
^^^^^^^^^^^
(((memberships resource)))
(((ECS,memberschips resource)))
Provides information of the affiliation of the calling participant to the
available communities. Available representations are `application/json` and
`application/xml`.

/sys/memberships:: GET provides a list of memberships for the
  appropriate calling participant. It implies all participants joining an
  appropriate community including the caller itself.

With the `itsyou` key the caller of the `/sys/memberships` resource will be
informed which participant in the different communities is assigned to him.

Following a sample representation in JSON:

-------------------------------------------------------
[
  {
    "community": {
      "name": "cc_courselinks",
      "description": "CampusConnect courselinks."
    },
    "participants": [
      {
        "name": "ILIAS-ECS Client 1",
        "itsyou": true,
        "org": {
          "name": "Leifos",
          "abbr": "LEI"
        },
        "mid": 1,
        "description": "Development participant.",
        "dns": "n/a",
        "email": "meyer@leifos.com"
      },
      {
        "name": "FreeIT.de Testparticipant",
        "itsyou": false,
        "org": {
          "name": "FreeIT Softwaredevelopment.",
          "abbr": "FreeIT"
        },
        "mid": 2,
        "description": "A general test participant.",
        "dns": "n/a",
        "email": "Heiko.Bernloehr@FreeIT.de"
      },
      {
        "name": "ILIAS-ECS Client 2",
        "itsyou": false,
        "org": {
          "name": "Leifos",
          "abbr": "LEI"
        },
        "mid": 3,
        "description": "",
        "dns": "n/a",
        "email": "meyer@leifos.com"
      }
    ]
  }
]
-------------------------------------------------------

Auths
^^^^^
(((auths resource)))
(((ECS,auths resource)))
This means authorization through one touch tokens. Provides a mechanism to
grant each participant authorization to consume services from any
service-providing-participant in an ECS network.

The interface is the same as for
https://ecs.uni-stuttgart.de/ecsa-wiki/HeikoBernloehr/FreeLancer/ECS/ecs2/core#application_resources[application
resources]. If you want to create an authorization token, you have to provide
at least a json formated URL (authorization context) as body text:

-------------------------------------------------------
curl ... -X POST -d '{"url":"https://freeit.de/mycourse"}' https://.../sys/auths
-------------------------------------------------------

and you will get back something like this:

-------------------------------------------------------
{
  "hash": "5a944e72346e6e3102d32ccfecc18862d23e1dc0",
  "sov": "2011-03-08T23:25:27+01:00",
  "eov": "2011-03-08T23:26:27+01:00",
  "url": "https://freeit.de/testcourse",
  "abbr": "LEI"
}
-------------------------------------------------------

hash:: povides the authorization token (one touch token) 
sov:: stands for start of validation 
eov:: stands for end of validation 
url:: provides the authorization context 
abbr:: provides an abbreviation of the participant which has been
  created the authorization token (deprecated) 

You're allowed to set the `sov` and/or `eov` to distinguish the validity
period of the authorization token. If you do not, the validity period is set to
one minute starting at current time.

The recommended way to fetch an authorization token when knowing the one touch hash:

-------------------------------------------------------
curl .... -X DELETE https://.../sys/auths/<one touch hash>
-------------------------------------------------------

This will return the auths representation (same structure/form as when
creating; see above) and delete it server side. If the authorization token is
outtimed, i.e. the current time is not between `sov` and `eov`, you will
get back a return code 409 (conflict) and following descriptional text in the
body: 'Authorization token outtimed'.

